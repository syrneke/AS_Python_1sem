# вар9

import math

def distance(point1, point2):
    """Вычисляет расстояние между двумя точками"""
    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)

def TypeTrl(x1, y1, x2, y2, x3, y3):
    """
    Определяет вид треугольника по координатам вершин
    
    Аргументы:
    x1, y1: координаты первой вершины
    x2, y2: координаты второй вершины
    x3, y3: координаты третьей вершины
    
    Возвращает:
    Строку с описанием вида треугольника
    """
    
    # Вычисляем длины сторон
    a = distance((x1, y1), (x2, y2))  # сторона между точками 1 и 2
    b = distance((x2, y2), (x3, y3))  # сторона между точками 2 и 3
    c = distance((x3, y3), (x1, y1))  # сторона между точками 3 и 1
    
    # Проверка на вырожденный треугольник (точки на одной прямой)
    if math.isclose(a + b, c) or math.isclose(a + c, b) or math.isclose(b + c, a):
        return "Точки лежат на одной прямой - это не треугольник"
    
    # Сортировка сторон для удобства проверок
    sides = sorted([a, b, c])
    
    result_types = []
    
    # Проверка на равносторонний треугольник (все стороны равны)
    if math.isclose(a, b) and math.isclose(b, c):
        result_types.append("равносторонний")
    
    # Проверка на равнобедренный треугольник (хотя бы две стороны равны)
    if (math.isclose(a, b) or math.isclose(b, c) or math.isclose(a, c)):
        if "равносторонний" not in result_types:
            result_types.append("равнобедренный")
    
    # Проверка на прямоугольный треугольник (теорема Пифагора)
    # Используем epsilon для учета погрешности вычислений с плавающей точкой
    epsilon = 1e-10
    if abs(sides[2]**2 - (sides[0]**2 + sides[1]**2)) < epsilon:
        result_types.append("прямоугольный")
    
    # Если не определился особый тип - обычный треугольник
    if not result_types:
        result_types.append("обычный")
    
    return " и ".join(result_types)

# Примеры использования функции
if __name__ == "__main__":
    # Тестовые примеры
    print("Примеры работы функции TypeTrl:")
    print("-" * 50)
    
    # Равносторонний треугольник
    print("1. Равносторонний треугольник (0,0), (2,0), (1,√3):")
    print(f"   Результат: {TypeTrl(0, 0, 2, 0, 1, math.sqrt(3))}")
    
    # Равнобедренный треугольник
    print("\n2. Равнобедренный треугольник (0,0), (4,0), (2,3):")
    print(f"   Результат: {TypeTrl(0, 0, 4, 0, 2, 3)}")
    
    # Прямоугольный треугольник
    print("\n3. Прямоугольный треугольник (0,0), (3,0), (0,4):")
    print(f"   Результат: {TypeTrl(0, 0, 3, 0, 0, 4)}")
    
    # Прямоугольный равнобедренный треугольник
    print("\n4. Прямоугольный равнобедренный треугольник (0,0), (4,0), (0,4):")
    print(f"   Результат: {TypeTrl(0, 0, 4, 0, 0, 4)}")
    
    # Обычный треугольник
    print("\n5. Обычный треугольник (0,0), (3,0), (1,2):")
    print(f"   Результат: {TypeTrl(0, 0, 3, 0, 1, 2)}")
    
    # Вырожденный случай
    print("\n6. Вырожденный случай (точки на одной прямой):")
    print(f"   Результат: {TypeTrl(0, 0, 1, 1, 2, 2)}")

# Альтернативная версия функции с использованием кортежей
def TypeTrl_v2(A, B, C):
    """
    Альтернативная версия функции, принимающая точки как кортежи
    
    Аргументы:
    A, B, C: кортежи с координатами (x, y)
    """
    x1, y1 = A
    x2, y2 = B
    x3, y3 = C
    return TypeTrl(x1, y1, x2, y2, x3, y3)

# Пример использования альтернативной версии
print("\n" + "="*50)
print("Использование альтернативной версии:")
print(f"Результат: {TypeTrl_v2((0, 0), (3, 0), (0, 4))}")


